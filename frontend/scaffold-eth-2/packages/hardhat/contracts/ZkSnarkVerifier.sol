// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

/**
 * @title IVerifier
 * @dev Interface for the circuit-specific verifier contract generated by snarkjs
 */
interface IVerifier {
    function verifyProof(
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256[] memory input
    ) external view returns (bool);
}

/**
 * @title ZkSnarkVerifier
 * @dev Manages ZK-SNARK proof verification for the energy trading system
 */
contract ZkSnarkVerifier is Ownable, ReentrancyGuard {
    // Mapping of proof types to their respective verifier contracts
    mapping(bytes32 => IVerifier) public verifiers;
    
    // Mapping of used proofs to prevent replay attacks
    mapping(bytes32 => bool) public verifiedProofs;
    
    // Mapping of authorized contracts that can request verification
    mapping(address => bool) public authorizedContracts;
    
    // Constants for different proof types
    bytes32 public constant ENERGY_VALIDITY = keccak256("ENERGY_VALIDITY");
    bytes32 public constant TRADE_VERIFICATION = keccak256("TRADE_VERIFICATION");
    bytes32 public constant CARBON_CREDIT = keccak256("CARBON_CREDIT");
    
    // Events
    event ProofVerified(bytes32 indexed proofType, bytes32 indexed proofHash, address indexed verifier);
    event VerifierUpdated(bytes32 indexed proofType, address verifier);
    event AuthorizedContractAdded(address indexed contractAddress);
    event AuthorizedContractRemoved(address indexed contractAddress);
    
    /**
     * @dev Constructor to set the initial owner
     */
    constructor() Ownable(msg.sender) {}

    
    /**
     * @dev Modifier to check if caller is authorized
     */
    modifier onlyAuthorized() {
        require(authorizedContracts[msg.sender], "Caller is not authorized");
        _;
    }
    
    /**
     * @dev Verify a ZK-SNARK proof
     * @param proofType Type of proof being verified
     * @param a First part of proof
     * @param b Second part of proof
     * @param c Third part of proof
     * @param input Public inputs to the proof
     */
    function verifyZkProof(
        bytes32 proofType,
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256[] memory input
    ) external nonReentrant onlyAuthorized returns (bool) {
        require(address(verifiers[proofType]) != address(0), "Verifier not set");
        
        // Generate proof hash
        bytes32 proofHash = keccak256(abi.encodePacked(proofType, a, b, c, input, block.timestamp));
        require(!verifiedProofs[proofHash], "Proof already used");
        
        // Verify proof
        bool isValid = verifiers[proofType].verifyProof(a, b, c, input);
        require(isValid, "Invalid ZK-SNARK proof");
        
        // Mark proof as used
        verifiedProofs[proofHash] = true;
        emit ProofVerified(proofType, proofHash, msg.sender);
        return true;
    }
    
    /**
     * @dev Set or update a verifier contract for a proof type
     * @param proofType Type of proof this verifier handles
     * @param _verifier Address of the verifier contract
     */
    function setVerifier(bytes32 proofType, address _verifier) external onlyOwner {
        require(_verifier != address(0), "Invalid verifier address");
        verifiers[proofType] = IVerifier(_verifier);
        emit VerifierUpdated(proofType, _verifier);
    }
    
    /**
     * @dev Add a contract to the authorized list
     * @param _contract Address of contract to authorize
     */
    function addAuthorizedContract(address _contract) external onlyOwner {
        require(_contract != address(0), "Invalid contract address");
        authorizedContracts[_contract] = true;
        emit AuthorizedContractAdded(_contract);
    }
    
    /**
     * @dev Remove a contract from the authorized list
     * @param _contract Address of contract to deauthorize
     */
    function removeAuthorizedContract(address _contract) external onlyOwner {
        authorizedContracts[_contract] = false;
        emit AuthorizedContractRemoved(_contract);
    }
    
    /**
     * @dev Check if a proof has been verified
     * @param proofHash Hash of the proof to check
     */
    function isProofVerified(bytes32 proofHash) external view returns (bool) {
        return verifiedProofs[proofHash];
    }
}
